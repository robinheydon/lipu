///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const std = @import ("std");

const token = @import ("token.zig");
const TokenKind = token.TokenKind;
const TokenIndex = token.TokenIndex;

const lipu = @import ("lipu.zig");
const Lipu = lipu.Lipu;
const FileIndex = lipu.FileIndex;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const NodeIndex = u32;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const Node = struct
{
    kind: TokenKind,
    file: FileIndex,
    index: TokenIndex = 0,
    child: NodeIndex = 0,
    next: NodeIndex = 0,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const Tree = struct
{
    nodes: std.ArrayList (Node),
    lipu: *Lipu,

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn init (allocator: std.mem.Allocator, owner: *Lipu) Tree
    {
        return .{
            .nodes = std.ArrayList (Node).init (allocator),
            .lipu = owner,
        };
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn deinit (self: *Tree) void
    {
        self.nodes.deinit ();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn append (self: *Tree, kind: TokenKind, index: TokenIndex, file: FileIndex) !void
    {
        try self.nodes.append (.{
            .kind = kind,
            .file = file,
            .index = index,
        });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn dump (self: Tree, writer: anytype) !void
    {
        try writer.writeAll ("\nTree");

        for (0.., self.nodes.items) |index, item|
        {
            const slice = self.lipu.getSlice (item.file, item.index);
            try writer.print ("\n  {} {s} \"{}\" ({},{})", .{index, @tagName (item.kind), std.zig.fmtEscapes (slice), item.child, item.next});
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
