///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const std = @import("std");
const testing = std.testing;

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const token_zig = @import ("token.zig");
const TokenIndex = token_zig.TokenIndex;
const TokenIter = token_zig.TokenIter;
const tokenize = token_zig.tokenize;

const tree_zig = @import ("tree.zig");
const Tree = tree_zig.Tree;

const parse_zig = @import ("parse.zig");
const parse = parse_zig.parse;

const string_zig = @import ("string.zig");
const StringIntern = string_zig.StringIntern;

pub const log = @import ("log.zig");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const version = std.SemanticVersion {.major = 0, .minor = 0, .patch = 0};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const LipuOptions = struct
{
    allocator : std.mem.Allocator,
    debug_tokens : bool = false,
};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub const FileIndex = u32;

pub const Lipu = struct
{
    allocator : std.mem.Allocator,
    debug_tokens : bool = false,
    files : std.ArrayList ([]const u8),
    filenames : std.StringHashMap (FileIndex),
    tree : Tree,
    strings : StringIntern,

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn deinit (self: *Lipu) void
    {
        for (self.files.items) |item|
        {
            self.allocator.free (item);
        }
        self.files.deinit ();

        var iter = self.filenames.iterator ();
        while (iter.next ()) |kv|
        {
            const filename = kv.key_ptr.*;
            self.allocator.free (filename);
        }
        self.filenames.deinit ();

        self.tree.deinit ();

        self.strings.deinit ();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn import (self: *Lipu, filename: []const u8) !void
    {
        const cwd = std.fs.cwd ();
        const content = try cwd.readFileAlloc (self.allocator, filename, std.math.maxInt (TokenIndex));

        const file : FileIndex = @intCast (self.files.items.len);
        const filename_copy = try self.allocator.dupe (u8, filename);
        try self.files.append (content);
        try self.filenames.put (filename_copy, file);

        var iter = token_zig.tokenize (content);
        if (self.debug_tokens)
        {
            const output = try iter.dump (self.allocator);
            defer self.allocator.free (output);
            log.debug ("tokens", "{s}", .{output});
        }

        try parse_zig.parse (self, &iter, file);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn include (self: *Lipu, content: []const u8, filename: []const u8) !void
    {
        const file : FileIndex = @intCast (self.files.items.len);
        const filename_copy = try self.allocator.dupe (u8, filename);
        try self.files.append (content);
        try self.filenames.put (filename_copy, file);

        var iter = tokenize (content);
        if (self.debug_tokens)
        {
            const output = try iter.dump (self.allocator);
            defer self.allocator.free (output);
            log.debug ("tokens", "{s}", .{output});
        }

        try parse (self, &iter, file);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn dump (self: Lipu, alloc: std.mem.Allocator) ![]const u8
    {
        var buffer = std.ArrayList (u8).init (alloc);
        const writer = buffer.writer ();
        // try writer.writeAll ("Document:");
        // var iter = self.filenames.iterator ();
        // while (iter.next ()) |kv|
        // {
            // const filename = kv.key_ptr.*;
            // const index = kv.value_ptr.*;
            // try writer.print ("\n  {}: {s}", .{index, filename});
        // }
        try self.tree.dump (writer);
        return buffer.toOwnedSlice ();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

    pub fn getSlice (self: Lipu, file: FileIndex, index: TokenIndex) []const u8
    {
        if (file >= self.files.items.len)
        {
            return "";
        }

        const content = self.files.items[file];
        var iter = TokenIter {
            .content = content,
            .index = index,
        };
        if (iter.next ()) |tk|
        {
            return tk.slice;
        }
        return "";
    }

    ///////////////////////////////////////////////////////////////////////////////////////////

};

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn init (options: LipuOptions) !*Lipu
{
    const self = try options.allocator.create (Lipu);

    self.* = .{
        .allocator = options.allocator,
        .debug_tokens = options.debug_tokens,
        .files = std.ArrayList ([]const u8).init (options.allocator),
        .filenames = std.StringHashMap (FileIndex).init (options.allocator),
        .tree = Tree.init (options.allocator, self),
        .strings = try string_zig.init (options.allocator),
    };

    return self;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

test "check version" {
    try testing.expectFmt("0.0.0", "{}", .{version});
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

test "tokens" {
    _ = @import ("parse.zig");
    _ = @import ("testing.zig");
    _ = @import ("token.zig");
    _ = @import ("value.zig");
    _ = @import ("string.zig");
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
