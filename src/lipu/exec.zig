///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const std = @import ("std");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

const lipu_zig = @import ("lipu.zig");
const Lipu = lipu_zig.Lipu;

const tree_zig = @import ("tree.zig");
const Tree = tree_zig.Tree;
const Node = tree_zig.Node;
const NodeIndex = tree_zig.NodeIndex;

const string_zig = @import ("string.zig");
const intern = string_zig.intern;

const log = @import ("log.zig");

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn exec (lipu: *Lipu, parse_tree: Tree) !Tree
{
    var tree = Tree.init (lipu.allocator, lipu);

    const index = try tree.append (null, .document, 0, 0);

    var iter = parse_tree.iterator (0);

    try exec_into (lipu, &tree, index, &iter);

    return tree;
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

fn exec_into (lipu: *Lipu, tree: *Tree, index: NodeIndex, iter: *Tree.Iterator) !void
{
    while (iter.next ()) |index_node|
    {
        const node_index = index_node.index;
        const node = index_node.node;

        switch (node.kind)
        {
            .document =>
            {
                var doc_iter = iter.children (node_index);
                try exec_into (lipu, tree, index, &doc_iter);
            },
            .open_block =>
            {
                const block = try tree.append (index, node.kind, node.index, node.file);
                var block_iter = iter.children (node_index);
                try exec_into (lipu, tree, block, &block_iter);
            },
            .command =>
            {
                try execute_command (lipu, tree, index, node, iter);
            },
            else =>
            {
                _ = try tree.append (index, node.kind, node.index, node.file);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

pub fn execute_command (lipu: *Lipu, tree: *Tree, index: NodeIndex, node: Node, iter: *Tree.Iterator) !void
{
    _ = tree;
    _ = index;
    _ = iter;

    const slice = lipu.getSlice (node.file, node.index);
    const str = try intern (slice);

    const maybe_value = lipu.lookup (str);
    if (maybe_value == null)
    {
        log.err ("Unknown command {s}", .{slice});
        return;
    }
    const value = maybe_value.?;
    log.trace ("ExecuteCommand {\"} = {}", .{str, value});
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
